from random import gauss
from random import seed as pyseed
from numpy.random import seed, randint, uniform
from numpy import zeros, ones, concatenate, logical_not, array
from numpy import sum as nsum

class UnBalancedDataSet(object) :
    """
    Parent class with the main methods: fit, transform and fit_transform
    """
    def __init__(self, ratio=1., random_state=None):
        self.ratio = ratio
        self.rs = random_state
        self.x = None
        self.y = None
        self.minc = None
        self.maxc = None
        self.ucd = {}
        self.out_x = None
        self.out_y = None
        self.num = None
	
    def resample(self):
        pass

    def fit(self, x, y):
        """
        Class method to find the relevant class statistics and store it.
        """

        self.x = x
        self.y = y
	 # Get all the unique elements in the array
        uniques = set(self.y)
	
	self.num = zeros((len(uniques), 2))

        # Create a dictionary to store the statistic for each element
        for elem in uniques:
            self.ucd[elem] = 0

        # Populate this dictionary with the class proportions
        for elem in self.y:
            self.ucd[elem] += 1

        # Find the minority and majority classes
        curre_min = len(y)
        curre_max = 0
	
	for key in self.ucd.keys():

            if self.ucd[key] < curre_min:
                self.minc = key
                curre_min = self.ucd[key]

            if self.ucd[key] > curre_max:
                self.maxc = key
                curre_max = self.ucd[key]

    def transform(self):
        """
        Class method to re-sample the dataset.
        """

        self.out_x, self.out_y = self.resample()

        return self.out_x, self.out_y

    def fit_transform(self, x, y):
        """
        Class method to fit and transform the data set automatically.
        """

        self.fit(x, y)
        self.out_x, self.out_y = self.resample()

        return self.out_x, self.out_y

    @staticmethod
    def is_tomek(y, nn_index, class_type):
        """
        is_tomek uses the target vector and the first neighbour of every sample
        point and looks for Tomek pairs. Returning a boolean vector with True for
        majority Tomek links.
        :param y:
            Target vector of the data set, necessary to keep track of whether a
            sample belongs to minority or not
        :param nn_index:
            The index of the closes nearest neighbour to a sample point.
        :param class_type:
            The label of the minority class.
        :return:
            Boolean vector on len( # samples ), with True for majority samples that
            are Tomek links.
        """
	# Initialize the boolean result as false, and also a counter
        links = zeros(len(y), dtype=bool)
        count = 0

        # Loop through each sample and looks whether it belongs to the minority
        # class. If it does, we don't consider it since we want to keep all
        # minority samples. If, however, it belongs to the majority sample we look
        # at its first neighbour. If its closest neighbour also has the current
        # sample as its closest neighbour, the two form a Tomek link.
        for ind, ele in enumerate(y):

            if ele == class_type:
                continue

            if y[nn_index[ind]] == class_type:

                # If they form a tomek link, put a True marker on this sample, and
                # increase counter by one.
                if nn_index[nn_index[ind]] == ind:
                    links[ind] = True
                    count += 1
	return links

    @staticmethod
    def make_samples(x, nn_data, y_type, nn_num, n_samples, step_size=1., random_state=None):
        """
        A support function that returns artificial samples constructed along the
        line connecting nearest neighbours.
	"""

	# A matrix to store the synthetic samples
        new = zeros((n_samples, len(x.T)))

        # Set seeds
        seed(random_state)
        seeds = randint(low=0, high=100*len(nn_num.flatten()), size=n_samples)

        # Randomly pick samples to construct neighbours from
        seed(random_state)
        samples = randint(low=0, high=len(nn_num.flatten()), size=n_samples)

        # Loop over the NN matrix and create new samples
        for i, n in enumerate(samples):
            # NN lines relate to original sample, columns to its nearest neighbours
            row, col = divmod(n, len(nn_num.T))

            # Take a step of random size (0,1) in the direction of the n nearest
            # neighbours
            seed(seeds[i])
            step = step_size * uniform()

            # Construct synthetic sample
            new[i] = x[row] - step * (x[row] - nn_data[nn_num[row, col]])

	# The returned target vector is simply a repetition of the minority label
        y_new = ones(len(new)) * y_type

        return new, y_new

    @staticmethod
    def in_danger(sample, y, m, class_type, nn_obj):
        """
        A minority sample is in danger if more than half of its nearest neighbours
        belong to the majority class. The exception being a minority sample for
        which all its nearest neighbours are from the majority class, in which case
        it is considered noise.
	"""
	# Find NN for current sample
        x = nn_obj.kneighbors(sample.reshape((1, len(sample))),
                              return_distance=False)[:, 1:]

        # Count how many NN belong to the minority class
        minority = 0
        for nn in x[0]:
            if y[nn] != class_type:
                continue
            else:
                minority += 1

        # Return True of False for in danger and not in danger or noise samples.
        if minority <= m/2 or minority == m:
            # for minority == k the sample is considered to be noise and won't be
            # used, similarly to safe samples
            return False
        else:
            return True

    @staticmethod
    def is_noise(sample, y, class_type, nn_obj):
        """
        Function to determine whether a given minority sample is noise
	"""
	# Find NN for current sample
        x = nn_obj.kneighbors(sample.reshape((1, len(sample))),
                              return_distance=False)[:, 1:]

        # Check if any neighbour belong to the minority class.
        for nn in x[0]:
            if y[nn] != class_type:
                continue
            else:
                return False

        # If the loop completed, it is noise.
        return True


